[{"categories":["Research"],"contents":"This is a study of a special type of concert in Hindustani classical music called Jasrangi Jugalbandi. This type of concert involves a male and a female singer singing the same keyboard notes in 2 different ragas (scales) using the concept of mode shifting or murchana.\nBackground Transposition In various forms of modal music, it is common to obtain multiple scales from the same set of notes by just changing the tonic note. This concept is called murchana in Indian classical music. Below is an example of such a type of murchana where the singer, Gayatri, sings the notes of raga Chandrakauns in the concert tonic, i.e. G# (playing in the tanpuras), followed by the same keyboard notes in raga Madhukauns by assuming the tonic to be the madhyam (fourth note), i.e. C# above the concert tonic.   The video is a snippet from a Ranjani Gayatri concert posted on YouTube available here.\nJasrangi Jugalbandi (JJ) This type of concert was first conceptualised by Pt. Jasraj in the year 2012. Since male and female vocalists usually have natural vocal ranges that differ by around 5-7 semitones, this concert allows them to sing in their comfortable tonics (Sa) using the concept of murchana with the same notes.\nHere is an example of such a concert by Dr. Ashwini Bhide Deshpande and Pt. Sanjeev Abhyankar singing ragas Abhogi and Kalavati respectively.   Our Research Motivations Through our conversations with musicians we identified the following challenges during interaction of singers in this format of concert:\n The singers have to preserve raga specific characteristics They also have to meaningfully link phrases  Hence we sought to analyse the following:\n Study the extent to which individual raga-specific characteristics are preserved in a JJ concert Study the interaction between the 2 singers in the JJ concert  Research Material Our paper will be presented in ISMIR 2021 and can be found here.\nHere is a video of me talking about our research paper: [Will be added soon]\nHere is our poster about the paper:    #the-canvas { border: 1px solid black; direction: ltr; width: 100%; height: auto; display: none; } #paginator { display: none; text-align: center; margin-bottom: 10px; } #loadingWrapper { display: none; justify-content: center; align-items: center; width: 100%; height: 350px; } #loading { display: inline-block; width: 50px; height: 50px; border: 3px solid #d2d0d0; ; border-radius: 50%; border-top-color: #383838; animation: spin 1s ease-in-out infinite; -webkit-animation: spin 1s ease-in-out infinite; } @keyframes spin { to { -webkit-transform: rotate(360deg); } } @-webkit-keyframes spin { to { -webkit-transform: rotate(360deg); } }  Previous Next \u0026nbsp; \u0026nbsp; Page:  /       window.onload = function() { var url = \"https:\\/\\/snnithya.github.io\\/\" + 'portfolio\\/01_jj\\/Poster 2.0.pdf'; var hidePaginator = \"\" === \"true\"; var hideLoader = \"\" === \"true\"; var selectedPageNum = parseInt(\"\") || 1; var pdfjsLib = window['pdfjs-dist/build/pdf']; pdfjsLib.GlobalWorkerOptions.workerSrc = \"https:\\/\\/snnithya.github.io\\/\" + '/js/pdf-js/build/pdf.worker.js'; var pdfDoc = null, pageNum = selectedPageNum, pageRendering = false, pageNumPending = null, scale = 3, canvas = document.getElementById('the-canvas'), ctx = canvas.getContext('2d'), paginator = document.getElementById(\"paginator\"), loadingWrapper = document.getElementById('loadingWrapper'); showPaginator(); showLoader(); function renderPage(num) { pageRendering = true; pdfDoc.getPage(num).then(function(page) { var viewport = page.getViewport({ scale: scale }); canvas.height = viewport.height; canvas.width = viewport.width; var renderContext = { canvasContext: ctx, viewport: viewport }; var renderTask = page.render(renderContext); renderTask.promise.then(function() { pageRendering = false; showContent(); if (pageNumPending !== null) { renderPage(pageNumPending); pageNumPending = null; } }); }); document.getElementById('page_num').textContent = num; } function showContent() { loadingWrapper.style.display = 'none'; canvas.style.display = 'block'; } function showLoader() { if (hideLoader) return loadingWrapper.style.display = 'flex'; canvas.style.display = 'none'; } function showPaginator() { if (hidePaginator) return paginator.style.display = 'block'; } function queueRenderPage(num) { if (pageRendering) { pageNumPending = num; } else { renderPage(num); } } function onPrevPage() { if (pageNum = pdfDoc.numPages) { return; } pageNum++; queueRenderPage(pageNum); } document.getElementById('next').addEventListener('click', onNextPage); pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) { pdfDoc = pdfDoc_; var numPages = pdfDoc.numPages; document.getElementById('page_count').textContent = numPages; if (pageNum  numPages) { pageNum = numPages } renderPage(pageNum); }); } \n","permalink":"https://snnithya.github.io/portfolio/01_jj/","tags":["MIR","Hindustani Music","Indian Classical Music"],"title":"Computational Analysis of Melodic Mode Switching"},{"categories":["Music"],"contents":"This is a presentation of a kajri (semi-classical song). The lyrics are:\nKehenawa mano, O radha rani (Listen to my words, O radha rani)\nNishi andhiyari kari bijuri chamake, room-jhoom barasat paani (It is the night time and dark with lightning. It is raining heavily)\nHaath jod tori binati karata hoon, na maane mori bani (With my hands together, I am pleading with you. But you are not listening to me)\nThis song can be interpreted as being sung either by Radha\u0026rsquo;s beloved, a sakhi (friend) or her mother in an attempt to pacify her anger. I was taught this composition by my guru, Dr. Ruchira Kedar.\nI was accompanied by Sri Koushik Bhat on the Tabla.\n  ","permalink":"https://snnithya.github.io/portfolio/02_kajri/","tags":["Semi Classical Music","Hindustani Music","Kajri"],"title":"Kajri - Kehenawa Mano O Radha Rani"},{"categories":["Music"],"contents":"This is an adaptation of the famous Bollywood song Piyu Bole, from the movie Parineeta with a twist. Half way through the cover, we jazzed things up a bit :) I hope you enjoy it!\nCredits: *Singing, Animations and vocal arrangements - Nithya Shikarpur *Flute fills - Pranav Shikarpur *All other instruments, mixing - Shikhar Rastogi\n  ","permalink":"https://snnithya.github.io/portfolio/03_piyu_bole/","tags":["Cover","Jazz","Bollywood"],"title":"Piyu Bole - with a jazz twist"},{"categories":["Music"],"contents":"This is an a cappella arrangement of the title track from the film Roja.\n  ","permalink":"https://snnithya.github.io/portfolio/04_roja/","tags":["Acapella","Bollywood","Arrangement"],"title":"Roja - Cover"},{"categories":["Music"],"contents":"This is a presentation of Raag Tilak Kamod that I recorded recently. The presentation includes a vilambit (slow-paced) song - Sur Sangat by Alladiya Khan. This composition is presented in a 7-beat rhythm cycle called Rupak Taal. This song is followed by a traditional tarana in a 12-beat rhythm cycle called Ek Taal.\nSri Koushik Bhat has accompanied me on the Tabla.\n  ","permalink":"https://snnithya.github.io/portfolio/05_tilak_kamod/","tags":["Hindustani Music","Indian Classical Music"],"title":"Raga Tilak Kamod"},{"categories":["Music"],"contents":"This was a fun cover of the song labb par aaye, from the tv series Bandish Bandits, that I did with my friend Anjali Upadhyaya. Throughout our schooling, both of us were very interested in the Indian Arts. We finally got around to making something together :) Hope you like it!\nCredits:\n Anjali Upadhyaya - Dancing, bol recitation Nithya Shikarpur - Singing, and all other song related aspects    ","permalink":"https://snnithya.github.io/portfolio/06_labb_par_aaye/","tags":["Semi Classical Music","Bollywood","Hindustani Music","Fusion"],"title":"Labb Par Aaye - Song + Dance"},{"categories":["Music"],"contents":"This is a song by the poet Basavanna in praise of Lord Shiva. Performed at Sripada Kshetra, Bangalore, India for the occassion of Shivaratri. This song is set in raga Madhuvanti and Bhajan Theka tala.\nCredits:\n Koushik Bhat - Tabla (Percussion accompaniment) Nithya Shikarpur - Vocals    ","permalink":"https://snnithya.github.io/portfolio/07_ullavarushivalaya/","tags":["Semi Classical Music","Hindustani Music","Bhajan"],"title":"Ullavarushivalaya - Song for shivaratri"},{"categories":["Music"],"contents":"Having spent more time stuck at home than was good for me, I was struck by an inspiration to write an jingle for square wheels. Apart from their obvious defects in functionality, I think they have a pretty nice aesthetic going on :) So here is an absurd short song I wrote, arranged and recorded for square wheels. I made the animations on Blender.\n  ","permalink":"https://snnithya.github.io/portfolio/08_square_wheels/","tags":["Original Composition","Animation","Arrangement","Quarantine Absurdity"],"title":"Square Wheels"},{"categories":["Music"],"contents":"Here are a quick set of drawings I drew on my phone for the song \u0026lsquo;Amma nanu devarane\u0026rsquo; to put an Instagram story. This is a song about little Krishna. Caught with butter all over his mouth by his mother Yashoda, he stubbonrly swears that he didn\u0026rsquo;t steal any butter and that everyone else got together and put butter on his mouth to frame him. The visual nature of this song inspired me to draw it out a little.\n  ","permalink":"https://snnithya.github.io/portfolio/09_amma_naanu/","tags":["Semi Classical Music","Hindustani Music","Bhajan","Drawing"],"title":"Amma Nanu Devarane - Devaranama"},{"categories":["Music"],"contents":"Here is our take on Waltz for Debby by Bill Evans. I had a lot of fun interpreting this very beautiful melody with Shikhar\u0026rsquo;s playing and adding a pinch of Indianness to the singing as well :)\nCredits\n Shikhar Rastogi - Keys Nithya Shikarpur - Vocals    ","permalink":"https://snnithya.github.io/portfolio/wfd/","tags":["Jazz","Harmony","Fusion"],"title":"Waltz for Debby"},{"categories":["Technical Projects"],"contents":"During a summer internship at Centre for infrastructure, Sustainable Transportation and Urban Planning (CiSTUP), Indian Institute of Sciences (IISc), Bangalore from May 2019 - July 2019, I worked on the visualisation and analysis of a phenomenon called bus bunching using data collected from BMTC buses in Bangalore. I was fortunate to work with Prof. Tarun Rambha who helped me navigate through domain knowledge that I wasn\u0026rsquo;t very familiar at the time.\nBus Bunching In public transport, bus bunching refers to the situation when 2 or more buses of the same route having evenly spaced schedules end up at the same place at the same time. For this, 1 or more buses have to violate their schedule. Causes for this could include traffic congestion, extra time taken by passengers to board or deborad the bus or temporary breakdowns of buses while on route. Effects of bus bunching can get magnified very easily. For instance, when two buses get bunched, the first bus usually gets overcrowded and the second goes near-empty. This becomes a vicious cycle that cannot be broken. This ultimately leads to inconsistent waiting times, not allowing passengers to fully rely on the bus system for their transport.\n Depiction of the effects of bus bunching. Taken from this link.\n  Data BMTC Bangalore Metropolitan Transport Corporation (BMTC) is a government agency that controls public transport bus service in Bengaluru.\nTypes of Data Collected We had access to ticketing and GPS data for a year from BMTC buses of multiple routes. Due to time constraints, I focused only on the data from January 1st, 2018. In addition, I chose only one route, with the most trips on this day - route #248 (Krishna Rajendra Market to Jalahalli Cross).\nVisualisation  Picture of visualisation of data\n  I have explained the meaning of all the components represented on the visualisation.\nMarkers Each marker represents a bus and is numbered in serial order. Buses bunched are green in colour and the other ones are red in colour.\nRoute Variables  Fare - Total fare collected by all buses on the route at a given point of time. Passengers - Total number of passangers that have boarded any bus on the route at a given point of time. Bunches - Number of bunching instances. Here, bunching instance is defined as an instant when 2 buses are travelling in the same direction but are within a certain bunching radius (in this case, 100m). Once a pair of buses undergo bunching in a particular trip, they are not counted again thus preventing double counting.  Route variables\n    Time Factor Time factor is defined as the number of seconds from the live data displayed per second in the simulation. This value can range from 10 to 1000.  Time factor\n  Bus Data It has the total fare collected and total number of passengers that have boarded the bus. The colour of the row changes based on whether it is bunched or not.  Bus data\n  Space Time Plot This a graph with the time passed on the X-axis and the distance travelled by the bus on the Y-axis (Distance is positive for the UP direction and negative for the DOWN direction). Each line plotted represents a di\u001bferent bus on the route. When two lines are parallel, it can be interpreted that they are consistently travelling with an even space between each other. However, when the lines intersect, we can see that they have bunched.  Space Time Plot\n  I used MySQL, Javascript (ChartJS), HTML and Python (pandas and modin) for this project. All the code associated along with a more detailed report can be found here\n","permalink":"https://snnithya.github.io/portfolio/bus_bunching/","tags":["Visualisation","Bus Bunching","HTML"],"title":"Bus Bunching Analysis and Visualisation"},{"categories":["Technical Projects"],"contents":"From July 2019 to May 2020, I worked with Dr. Abhishek Tripathi as an intern at McAfee. This was my first project there and also contributed towards my undergraduate thesis. This project aimed to develop a malware detection system targeted for IoT devices.\nIoT devices Internet of Things (IoT) refers to smart devices that collect and share data over the internet. These devices have found a use case in almost every setting. Smart devices encompass a large spectrum of gadgets ranging from small wearable smart watches to bigger air conditioning systems. IoT devices have found their way into several fields including medicine, entertainment and governance.\nMotivation to develop malware detection for these devices:   IoT devices are becoming increasingly popular A report by Business Insider (dated 2017), states that there will be 30 billion IoT devices by the year 2020 [link]. This trend seems to only be going upwards since then.\n  Lack of security standards\nThis surge in IoT devices has developed too quickly for the security standards to be maintained. This has made these devices highly vulnerable to malware attacks.\n  Low compute resources on such devices\nMost of these devices were designed to collect and share data to a centralized server that process the data and sends back instructions. Hence due to the lesser amount of compute resources present on IoT devices, it is difficult to use traditional malware detection methods on the device itself.\n  TLS Features TLS (Transport Layer Security) is a cryptographic protocol that allows data being transmitted over the internet to be encrypted. While it is true that an the increased use of TLS over the internet, ensures greater security, it has also allowed malware to encrypt its traffic, thus making it hard to detect. Earlier methods of malware detection from network packets used features like the port numbers, IP addresses or patterns in the payload. These features cannot be used with encrypted traffic as they become unavailable with simple feature extraction.\nHence we rely on features that can be extracted from encrypted network traffic, i.e., TLS Features. Each TLS encrypted exchange of packets begins with a TLS handshake involving the exchange of a few unencrypted packets. We extract our features from this series of packets.\n Basic TLS handshake from where we extract features. [Image source link]\n  Models developed Logistic Regression A logistic regression model involves only the computation of a sigmoid function in order to give a prediction. This can easily be done on a router, with limited memory requirements. In order to ensure that the predictions can be made within a few milliseconds (to prevent the malware from getting passed on to the device from the router), we retained only the important features determined during our model training. Only these limited number of features were used for the model prediction, thus reducing the prediction time drastically.\nDeep Learning (Autoencoders) Since, in the real world, malware packets are usually an anomaly among mostly benign packets, we decided to experiment with autoencoders due to their good performance with anomaly detection.\nAlthough in actuality, malware data is much less seen than benign data, this was not the case with the dataset we had access to. Due to privacy issues, it is surprisingly more difficult to collect benign data. Hence we developed 2 autoencoders, trained on malware and benign data separately. A combination of the predictions from both models were used to determine whether a packet was malicious or not.\nThis project contributed towards my undergraduate thesis, available at this link.\n","permalink":"https://snnithya.github.io/portfolio/tls/","tags":["Malware Detection","McAfee","TLS"],"title":"Malware Detection for IoT devices"}]